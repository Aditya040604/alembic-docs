
## 🧩 The Situation

You have an existing database table — let’s say `users` — with **existing data**:

|id|username|email|
|---|---|---|
|1|"adi"|NULL|
|2|"john"|NULL|

Now, you change your model:

```python
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    username = Column(String(50), unique=True)
    email = Column(String(100), unique=True)
    is_active = Column(Boolean, nullable=False)  # <-- newly added
```

You run:

```bash
alembic revision --autogenerate -m "add is_active column"
alembic upgrade head
```

---

## 💥 What Happens?

Alembic will generate a migration like this:

```python
def upgrade():
    op.add_column('users', sa.Column('is_active', sa.Boolean(), nullable=False))
```

Then when you apply (`upgrade head`)...

🚨 **BOOM!**  
Database says:

> “Cannot add NOT NULL column without a default value — existing rows would violate the constraint.”

Why?  
Because the table already has rows, and the database doesn’t know what value to give them for `is_active` (it can’t leave it NULL, since you said `nullable=False`).

---

## 🧠 Your Options (the Professional Way)

Let’s fix this smartly.

### ✅ Option 1: Give it a Default Value in the Migration

When autogenerate doesn’t know what to do, you **edit the migration file manually**.

Modify it like this:

```python
def upgrade():
    op.add_column('users', sa.Column('is_active', sa.Boolean(), nullable=False, server_default='1'))
```

Now all existing rows will have `is_active = True`,  
and new rows will require a value (since `nullable=False`).

Then, you can **remove** the server default later if you don’t want it permanent.

Example follow-up migration:

```python
def upgrade():
    op.alter_column('users', 'is_active', server_default=None)
```

---

### ✅ Option 2: Allow Null Temporarily, Then Fill Data, Then Make Non-Null

This is the **cleaner, production-safe** approach 👇

#### Step 1: Add column as nullable (safe for old data)

```python
def upgrade():
    op.add_column('users', sa.Column('is_active', sa.Boolean(), nullable=True))
```

#### Step 2: Update existing data using SQL

```python
op.execute("UPDATE users SET is_active = 1 WHERE is_active IS NULL")
```

#### Step 3: Alter the column to `nullable=False`

```python
op.alter_column('users', 'is_active', nullable=False)
```

Final version:

```python
def upgrade():
    op.add_column('users', sa.Column('is_active', sa.Boolean(), nullable=True))
    op.execute("UPDATE users SET is_active = 1 WHERE is_active IS NULL")
    op.alter_column('users', 'is_active', nullable=False)
```

✅ Now the migration works perfectly for existing and future rows.

---

### 🚫 Option 3: Just Use `nullable=True`

If you don’t actually need strict enforcement, just leave it nullable and handle it in code (e.g., default to `True` in Python). But this is less robust.

---

## 🧠 Why Alembic Can’t Fully Auto-Handle It

Alembic’s `--autogenerate` works by comparing:

- your current models (via SQLAlchemy’s `Base.metadata`)
    
- your existing DB schema
    

It doesn’t know **what default values to use for new non-null columns**, because:

- That’s a **business logic** decision (you know your data better than Alembic does).
    

So it leaves that part for you to edit manually. (Just like `git merge` can’t decide which conflicting line you want to keep.)

---

## 🧰 Visual Summary

```
Step 1: Add new NOT NULL column
      ↓
DB refuses because old rows have no value
      ↓
Step 2: Give a default or fill existing rows
      ↓
Now DB schema and data are consistent ✅
```

---

## ⚙️ Pro Tip (Forward-thinking)

If you’re doing frequent migrations on live data:

- **Always test migrations on a copy** of production DB first.
    
- **Keep nullable=True initially**, backfill values, then **tighten constraints** later.
    
- You can also use **server_default=sa.text("now()")** for timestamps or **0/1** for flags.
    

Example for timestamps:

```python
op.add_column('users', sa.Column('created_at', sa.DateTime(), server_default=sa.text('NOW()'), nullable=False))
```

---

## 🧩 TL;DR

|Scenario|Solution|
|---|---|
|Adding nullable column|Works fine|
|Adding NOT NULL column (no data)|Works fine|
|Adding NOT NULL column (existing data)|❌ Error unless you specify a default or update old rows|
|Best practice|Add nullable first → fill data → alter to non-null|

---

If you want, I can show you a **live example** (step-by-step Alembic migration) demonstrating this exact case with fake data — so you can try it in your FastAPI project.  
Would you like me to show that?