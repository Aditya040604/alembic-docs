
## ğŸ§© The Situation

You have an existing database table â€” letâ€™s say `users` â€” with **existing data**:

|id|username|email|
|---|---|---|
|1|"adi"|NULL|
|2|"john"|NULL|

Now, you change your model:

```python
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    username = Column(String(50), unique=True)
    email = Column(String(100), unique=True)
    is_active = Column(Boolean, nullable=False)  # <-- newly added
```

You run:

```bash
alembic revision --autogenerate -m "add is_active column"
alembic upgrade head
```

---

## ğŸ’¥ What Happens?

Alembic will generate a migration like this:

```python
def upgrade():
    op.add_column('users', sa.Column('is_active', sa.Boolean(), nullable=False))
```

Then when you apply (`upgrade head`)...

ğŸš¨ **BOOM!**  
Database says:

> â€œCannot add NOT NULL column without a default value â€” existing rows would violate the constraint.â€

Why?  
Because the table already has rows, and the database doesnâ€™t know what value to give them for `is_active` (it canâ€™t leave it NULL, since you said `nullable=False`).

---

## ğŸ§  Your Options (the Professional Way)

Letâ€™s fix this smartly.

### âœ… Option 1: Give it a Default Value in the Migration

When autogenerate doesnâ€™t know what to do, you **edit the migration file manually**.

Modify it like this:

```python
def upgrade():
    op.add_column('users', sa.Column('is_active', sa.Boolean(), nullable=False, server_default='1'))
```

Now all existing rows will have `is_active = True`,  
and new rows will require a value (since `nullable=False`).

Then, you can **remove** the server default later if you donâ€™t want it permanent.

Example follow-up migration:

```python
def upgrade():
    op.alter_column('users', 'is_active', server_default=None)
```

---

### âœ… Option 2: Allow Null Temporarily, Then Fill Data, Then Make Non-Null

This is the **cleaner, production-safe** approach ğŸ‘‡

#### Step 1: Add column as nullable (safe for old data)

```python
def upgrade():
    op.add_column('users', sa.Column('is_active', sa.Boolean(), nullable=True))
```

#### Step 2: Update existing data using SQL

```python
op.execute("UPDATE users SET is_active = 1 WHERE is_active IS NULL")
```

#### Step 3: Alter the column to `nullable=False`

```python
op.alter_column('users', 'is_active', nullable=False)
```

Final version:

```python
def upgrade():
    op.add_column('users', sa.Column('is_active', sa.Boolean(), nullable=True))
    op.execute("UPDATE users SET is_active = 1 WHERE is_active IS NULL")
    op.alter_column('users', 'is_active', nullable=False)
```

âœ… Now the migration works perfectly for existing and future rows.

---

### ğŸš« Option 3: Just Use `nullable=True`

If you donâ€™t actually need strict enforcement, just leave it nullable and handle it in code (e.g., default to `True` in Python). But this is less robust.

---

## ğŸ§  Why Alembic Canâ€™t Fully Auto-Handle It

Alembicâ€™s `--autogenerate` works by comparing:

- your current models (via SQLAlchemyâ€™s `Base.metadata`)
    
- your existing DB schema
    

It doesnâ€™t know **what default values to use for new non-null columns**, because:

- Thatâ€™s a **business logic** decision (you know your data better than Alembic does).
    

So it leaves that part for you to edit manually. (Just like `git merge` canâ€™t decide which conflicting line you want to keep.)

---

## ğŸ§° Visual Summary

```
Step 1: Add new NOT NULL column
      â†“
DB refuses because old rows have no value
      â†“
Step 2: Give a default or fill existing rows
      â†“
Now DB schema and data are consistent âœ…
```

---

## âš™ï¸ Pro Tip (Forward-thinking)

If youâ€™re doing frequent migrations on live data:

- **Always test migrations on a copy** of production DB first.
    
- **Keep nullable=True initially**, backfill values, then **tighten constraints** later.
    
- You can also use **server_default=sa.text("now()")** for timestamps or **0/1** for flags.
    

Example for timestamps:

```python
op.add_column('users', sa.Column('created_at', sa.DateTime(), server_default=sa.text('NOW()'), nullable=False))
```

---

## ğŸ§© TL;DR

|Scenario|Solution|
|---|---|
|Adding nullable column|Works fine|
|Adding NOT NULL column (no data)|Works fine|
|Adding NOT NULL column (existing data)|âŒ Error unless you specify a default or update old rows|
|Best practice|Add nullable first â†’ fill data â†’ alter to non-null|

---

If you want, I can show you a **live example** (step-by-step Alembic migration) demonstrating this exact case with fake data â€” so you can try it in your FastAPI project.  
Would you like me to show that?